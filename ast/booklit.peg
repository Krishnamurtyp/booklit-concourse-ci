{
  package ast

  import "strings"

  func ifaceStr(val interface{}) string {
    str := ""
    for _, seg := range val.([]interface{}) {
      str = str + string(seg.([]byte))
    }

    return str
  }

  func ifaceSequences(val interface{}) []Sequence {
    seq := []Sequence{}
    for _, node := range val.([]interface{}) {
      seq = append(seq, node.(Sequence))
    }

    return seq
  }

  func ifaceNodes(val interface{}) []Node {
    nodes := []Node{}
    for _, node := range val.([]interface{}) {
      nodes = append(nodes, node.(Node))
    }

    return nodes
  }
}

Booklit <- node:Paragraphs !. {
  return node, nil
}

InlineCode <- '`' node:([^`]+ { return String(c.text), nil }) '`' {
  return Invoke{
    Function: "code",
    Arguments: []Node{node.(Node)},

    Location: Location{
      Line:   c.pos.line,
      Col:    c.pos.col,
      Offset: c.pos.offset,
    },
  }, nil
}

StarItalic <- '*' node:WrappedLine '*' {
  return Invoke{
    Function: "italic",
    Arguments: []Node{node.(Node)},

    Location: Location{
      Line:   c.pos.line,
      Col:    c.pos.col,
      Offset: c.pos.offset,
    },
  }, nil
}

UnderscoreItalic <- '_' node:WrappedLine '_' {
  return Invoke{
    Function: "italic",
    Arguments: []Node{node.(Node)},

    Location: Location{
      Line:   c.pos.line,
      Col:    c.pos.col,
      Offset: c.pos.offset,
    },
  }, nil
}

StarBold <- "**" node:WrappedLine "**" {
  return Invoke{
    Function: "bold",
    Arguments: []Node{node.(Node)},

    Location: Location{
      Line:   c.pos.line,
      Col:    c.pos.col,
      Offset: c.pos.offset,
    },
  }, nil
}

UnderscoreBold <- "__" node:WrappedLine "__" {
  return Invoke{
    Function: "bold",
    Arguments: []Node{node.(Node)},

    Location: Location{
      Line:   c.pos.line,
      Col:    c.pos.col,
      Offset: c.pos.offset,
    },
  }, nil
}

Link <- '[' title:WrappedLine ']' '(' destination:[^)]+ ')' {
  return Invoke{
    Function: "link",
    Arguments: []Node{title.(Node), String(ifaceStr(destination))},

    Location: Location{
      Line:   c.pos.line,
      Col:    c.pos.col,
      Offset: c.pos.offset,
    },
  }, nil
}

Image <- "![" title:WrappedLine? ']' '(' destination:[^)]+ ')' {
  args := []Node{
    String(ifaceStr(destination)),
  }

  if title != nil {
    args = append(args, title.(Node))
  }

  return Invoke{
    Function: "image",
    Arguments: args,

    Location: Location{
      Line:   c.pos.line,
      Col:    c.pos.col,
      Offset: c.pos.offset,
    },
  }, nil
}

Paragraphs <- CommentSpacing* paragraphs:(p:(Header / Quote / List / Paragraph) CommentSpacing* { return p, nil })+ {
  return Sequence(ifaceNodes(paragraphs)), nil
}

LineBreak <- "\n" / "\r\n"

CommentSpacing <- LineBreak / Comment

Paragraph <- lines:(l:Line LineBreak? { return l, nil })+ {
  return Paragraph(ifaceSequences(lines)), nil
}

QuotedParagraph <- WS lines:('>' l:Line LineBreak? { return l, nil })+ {
  return Paragraph(ifaceSequences(lines)), nil
}

Quote <- paras:(p:QuotedParagraph (WS '>' WS LineBreak)? { return p, nil })+ {
  return Invoke{
    Function: "quote",
    Arguments: []Node{Sequence(ifaceNodes(paras))},
    Location: Location{
      Line:   c.pos.line,
      Col:    c.pos.col,
      Offset: c.pos.offset,
    },
  }, nil
}

StarTightList <- WS lines:('*' l:Line LineBreak? { return l, nil })+ {
  return Invoke{
    Function: "list",
    Arguments: ifaceNodes(paras),
    Location: Location{
      Line:   c.pos.line,
      Col:    c.pos.col,
      Offset: c.pos.offset,
    },
  }, nil
}

IndentedLines <- lines:((Linebreak /  "  " l:Line LineBreak? { return l, nil })+ {
}

StarLooseListItem <- "* " l:Line LineBreak IndentedLines* {
  return Paragraph(ifaceSequences(lines)), nil
}

StarLooseList <- items:StartLooseListItem+ {
  return Invoke{
    Function: "list",
    Arguments: ifaceNodes(items),
    Location: Location{
      Line:   c.pos.line,
      Col:    c.pos.col,
      Offset: c.pos.offset,
    },
  }, nil
}

StarList <- StarTightList / StarLooseList
DashList <- DashTightList / DashLooseList

List <- StarList / DashList

Sentence <- words:(Word)+ {
  return Sequence(ifaceNodes(words)), nil
}

Line <- WS node:Sentence { return node, nil }

Header <- depth:'#'+ line:Line {
  sub := strings.Repeat("sub", len(depth.([]interface{}))-1)
  return Invoke{
    Function: sub+"header",
    Arguments: []Node{line.(Node)},

    Location: Location{
      Line:   c.pos.line,
      Col:    c.pos.col,
      Offset: c.pos.offset,
    },
  }, nil
}

Flow <- String / Invoke / Image / Link / InlineCode / StarBold / UnderscoreBold / StarItalic / UnderscoreItalic / Interpolated

Word <- Comment? val:Flow Comment? {
  return val, nil
}

Comment <- WS "{-" (Comment / !"-}" .)* "-}"

Interpolated <- '{' word:Word? '}' {
  if word == nil {
    return Sequence{}, nil
  } else {
    return word, nil
  }
}

WrappedLine <- firstWord:Word words:(Word / Split)* {
  allWords := append([]interface{}{firstWord}, words.([]interface{})...)
  return Sequence(ifaceNodes(allWords)), nil
}

Split <- LineBreak WS { return String(" "), nil }

String <- ([^\\{}*_`[\]!\r\n]+ / '!' !'[') { return String(c.text), nil } / '\\' [\\{}*_`[\]!] { return String(c.text[1:]), nil }

VerbatimString <- str:[^\r\n}]+ {
  return String(c.text), nil
} / '}' !"}}" {
  return String(c.text), nil
}

PreformattedLine <- indent:Indent words:Word* LineBreak {
  line := []Node{String(indent.(string))}
  line = append(line, ifaceNodes(words)...)
  return Sequence(line), nil
}

Preformatted <- LineBreak lines:PreformattedLine* {
  delete(c.globalStore, "indent-skip")
  return Preformatted(ifaceSequences(lines)), nil
}

VerbatimLine <- indent:Indent words:VerbatimString* LineBreak {
  line := []Node{String(indent.(string))}
  line = append(line, ifaceNodes(words)...)
  return Sequence(line), nil
}

Verbatim <- LineBreak lines:VerbatimLine* {
  delete(c.globalStore, "indent-skip")
  return Preformatted(ifaceSequences(lines)), nil
}

Invoke <- '\\' name:([a-z-]+) args:(Argument*) {
  return Invoke{
    Function: ifaceStr(name),
    Arguments: ifaceNodes(args),

    Location: Location{
      Line:   c.pos.line,
      Col:    c.pos.col,
      Offset: c.pos.offset,
    },
  }, nil
}

VerbatimArg <- "{{{" node:Verbatim WS "}}}" {
  return node, nil
}

PreformattedArg <- "{{" node:Preformatted WS "}}" {
  return node, nil
}

EmptyArg <- CommentSpacing* { return nil, nil }

Arg <- '{' node:(WrappedLine / ParaArg / EmptyArg)? '}' {
  if node == nil {
    return String(""), nil
  } else {
    return node, nil
  }
}

ParaArg <- paras:Paragraphs WS {
  return paras, nil
}

Argument <- VerbatimArg / PreformattedArg / Arg

Indent <- WS {
  skip := len(c.text)

  i, found := c.globalStore["indent-skip"]
  if found {
    skip = i.(int)
  } else {
    c.globalStore["indent-skip"] = skip
  }

  if skip <= len(c.text) {
    return string(c.text[skip:]), nil
  } else {
    return "", nil
  }
}

WS <- [ \t]*
